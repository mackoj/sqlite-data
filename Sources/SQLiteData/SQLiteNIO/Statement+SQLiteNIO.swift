import Foundation
import NIOCore
import StructuredQueriesCore

#if SQLITE_ENGINE_SQLITENO
import SQLiteNIO

/// Extension to execute StructuredQueries statements using SQLiteNIO
extension StructuredQueriesCore.Statement {
  
  /// Executes a structured query on the given SQLiteNIO connection.
  ///
  /// For example:
  ///
  /// ```swift
  /// try await connection.run { db in
  ///   try await Player.insert { $0.name } values: { "Arthur" }
  ///     .execute(db)
  ///   // INSERT INTO "players" ("name")
  ///   // VALUES ('Arthur');
  /// }
  /// ```
  ///
  /// - Parameter connection: A SQLiteNIO connection.
  @inlinable
  public func execute(_ connection: SQLiteConnection) async throws where QueryValue == () {
    var (sql, bindings) = query.prepare { _ in "?" }
    if sql.isEmpty {
      sql = "SELECT 1 WHERE 0 -- Empty query generated by StructuredQueries"
    }
    
    let sqliteBindings = try bindings.map { binding -> SQLiteData in
      try binding.sqliteData
    }
    
    _ = try await connection.query(sql, sqliteBindings)
  }
  
  /// Returns an array of all values fetched from the database.
  ///
  /// For example:
  ///
  /// ```swift
  /// let players = try await connection.run { db in
  ///   let lastName = "O'Reilly"
  ///   try await Player
  ///     .where { $0.lastName == lastName }
  ///     .fetchAll(db)
  ///   // SELECT … FROM "players"
  ///   // WHERE "players"."lastName" = 'O''Reilly'
  /// }
  /// ```
  ///
  /// - Parameter connection: A SQLiteNIO connection.
  /// - Returns: An array of all values decoded from the database.
  @inlinable
  public func fetchAll(_ connection: SQLiteConnection) async throws -> [QueryValue.QueryOutput]
  where QueryValue: QueryRepresentable, QueryValue.QueryOutput: Decodable {
    var (sql, bindings) = query.prepare { _ in "?" }
    if sql.isEmpty {
      sql = "SELECT 1 WHERE 0 -- Empty query generated by StructuredQueries"
    }
    
    let sqliteBindings = try bindings.map { binding -> SQLiteData in
      try binding.sqliteData
    }
    
    let rows = try await connection.query(sql, sqliteBindings)
    return try rows.map { try $0.decode(QueryValue.QueryOutput.self) }
  }
  
  /// Returns a single value fetched from the database.
  ///
  /// For example:
  ///
  /// ```swift
  /// let player = try await connection.run { db in
  ///   let lastName = "O'Reilly"
  ///   try await Player
  ///     .where { $0.lastName == lastName }
  ///     .limit(1)
  ///     .fetchOne(db)
  ///   // SELECT … FROM "players"
  ///   // WHERE "players"."lastName" = 'O''Reilly'
  ///   // LIMIT 1
  /// }
  /// ```
  ///
  /// - Parameter connection: A SQLiteNIO connection.
  /// - Returns: A single value decoded from the database.
  @inlinable
  public func fetchOne(_ connection: SQLiteConnection) async throws -> QueryValue.QueryOutput?
  where QueryValue: QueryRepresentable, QueryValue.QueryOutput: Decodable {
    var (sql, bindings) = query.prepare { _ in "?" }
    if sql.isEmpty {
      sql = "SELECT 1 WHERE 0 -- Empty query generated by StructuredQueries"
    }
    
    let sqliteBindings = try bindings.map { binding -> SQLiteData in
      try binding.sqliteData
    }
    
    let rows = try await connection.query(sql, sqliteBindings)
    return try rows.first.map { try $0.decode(QueryValue.QueryOutput.self) }
  }
}

/// Extension to convert QueryBinding to SQLiteData
extension QueryBinding {
  @inlinable
  var sqliteData: SQLiteData {
    get throws {
      switch self {
      case let .blob(blob):
        var buffer = ByteBufferAllocator().buffer(capacity: blob.count)
        buffer.writeBytes(blob)
        return .blob(buffer)
      case let .bool(bool):
        return .integer(bool ? 1 : 0)
      case let .date(date):
        return .text(date.iso8601String)
      case let .double(double):
        return .float(double)
      case let .int(int):
        return .integer(Int(int))
      case .null:
        return .null
      case let .text(text):
        return .text(text)
      case let .uint(uint) where uint <= UInt64(Int.max):
        return .integer(Int(uint))
      case let .uint(uint):
        throw IntOverflowError(unsignedInteger: uint)
      case let .uuid(uuid):
        return .text(uuid.uuidString.lowercased())
      case let .invalid(error):
        throw error
      }
    }
  }
}

@usableFromInline
struct IntOverflowError: Error {
  let unsignedInteger: UInt64
  @usableFromInline
  init(unsignedInteger: UInt64) {
    self.unsignedInteger = unsignedInteger
  }
}

#endif
