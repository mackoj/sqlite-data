#if canImport(SQLiteNIO)
import Dependencies
import Foundation
import NIOCore
import SQLiteNIO
import Sharing
import StructuredQueriesCore

/// SQLiteNIO extensions for FetchOne property wrapper
extension FetchOne {
  
  /// Initializes this property with a query that fetches the first row from a table using SQLiteNIO.
  ///
  /// Example with explicit connection:
  /// ```swift
  /// @FetchOne(User.where { $0.id == 1 }, connection: sqliteConnection) var user
  /// ```
  ///
  /// Example with default connection:
  /// ```swift
  /// @FetchOne(User.where { $0.id == 1 }) var user
  /// ```
  ///
  /// - Parameters:
  ///   - wrappedValue: A default value to associate with this property.
  ///   - connection: The SQLiteNIO connection to read from. If `nil`, uses `@Dependency(\.defaultSQLiteConnection)`.
  public init(
    wrappedValue: sending Value,
    connection: SQLiteConnection? = nil
  )
  where
    Value: StructuredQueriesCore.Table & QueryRepresentable,
    Value.QueryOutput == Value,
    Value: Decodable
  {
    @Dependency(\.defaultSQLiteConnection) var defaultConnection
    let actualConnection = connection ?? defaultConnection
    
    let statement = Value.all.selectStar().asSelect().limit(1)
    sharedReader = SharedReader(
      wrappedValue: wrappedValue,
      .fetchNIO(FetchOneStatementNIORequest(statement: statement), connection: actualConnection)
    )
  }
  
  /// Initializes this property with a query that fetches the first row from a table using SQLiteNIO.
  ///
  /// - Parameters:
  ///   - wrappedValue: A default value to associate with this property.
  ///   - connection: The SQLiteNIO connection to read from. If `nil`, uses `@Dependency(\.defaultSQLiteConnection)`.
  public init(
    wrappedValue: sending Value,
    connection: SQLiteConnection? = nil
  )
  where
    Value: _OptionalProtocol & Decodable,
    Value: StructuredQueriesCore.Table,
    Value.QueryOutput == Value,
    Value.Wrapped: Decodable
  {
    @Dependency(\.defaultSQLiteConnection) var defaultConnection
    let actualConnection = connection ?? defaultConnection
    
    let statement = Value.all.selectStar().asSelect().limit(1)
    sharedReader = SharedReader(
      wrappedValue: wrappedValue,
      .fetchNIO(FetchOneStatementNIOOptionalRequest(statement: statement), connection: actualConnection)
    )
  }
  
  /// Initializes this property with a query associated with the wrapped value using SQLiteNIO.
  ///
  /// Example:
  /// ```swift
  /// @FetchOne(User.count, connection: sqliteConnection) var userCount = 0
  /// ```
  ///
  /// - Parameters:
  ///   - wrappedValue: A default value to associate with this property.
  ///   - statement: A query associated with the wrapped value.
  ///   - connection: The SQLiteNIO connection to read from.
  public init<V: QueryRepresentable & Decodable>(
    wrappedValue: Value,
    _ statement: some StructuredQueriesCore.Statement<V>,
    connection: SQLiteConnection? = nil
  )
  where
    Value == V.QueryOutput,
    V.QueryOutput: Decodable
  {
    @Dependency(\.defaultSQLiteConnection) var defaultConnection
    let actualConnection = connection ?? defaultConnection
    
    sharedReader = SharedReader(
      wrappedValue: wrappedValue,
      .fetchNIO(
        FetchOneStatementNIORequest(statement: statement),
        connection: actualConnection
      )
    )
  }
  
  /// Initializes this property with a query associated with an optional value using SQLiteNIO.
  ///
  /// - Parameters:
  ///   - wrappedValue: A default value to associate with this property.
  ///   - statement: A query associated with the wrapped value.
  ///   - connection: The SQLiteNIO connection to read from. If `nil`, uses `@Dependency(\.defaultSQLiteConnection)`.
  public init<V: QueryRepresentable & Decodable>(
    wrappedValue: Value = nil,
    _ statement: some StructuredQueriesCore.Statement<V>,
    connection: SQLiteConnection? = nil
  )
  where
    Value == V.QueryOutput?,
    V.QueryOutput: Decodable
  {
    @Dependency(\.defaultSQLiteConnection) var defaultConnection
    let actualConnection = connection ?? defaultConnection
    
    sharedReader = SharedReader(
      wrappedValue: wrappedValue,
      .fetchNIO(
        FetchOneStatementNIOOptionalValueRequest(statement: statement),
        connection: actualConnection
      )
    )
  }
}

/// Request type for FetchOne with SQLiteNIO (non-optional)
private struct FetchOneStatementNIORequest<V: QueryRepresentable & Decodable>: SQLiteNIOFetchRequest where V.QueryOutput: Decodable {
  typealias Value = V.QueryOutput
  
  let sql: String
  let bindings: [QueryBinding]
  
  init(statement: some StructuredQueriesCore.Statement<V>) {
    let (sql, bindings) = statement.query.prepare { _ in "?" }
    self.sql = sql.isEmpty ? "SELECT 1 WHERE 0 -- Empty query generated by StructuredQueries" : sql
    self.bindings = bindings
  }
  
  // SQLiteNIO fetch method
  func fetch(_ connection: SQLiteConnection) async throws -> V.QueryOutput {
    let sqliteBindings = try bindings.map { binding -> SQLiteData in
      try binding.sqliteData
    }
    
    let rows = try await connection.query(sql, sqliteBindings)
    guard let row = rows.first else { throw NotFound() }
    return try row.decode(V.QueryOutput.self)
  }
  
  var observedTables: Set<String> {
    // TODO: Extract table names from statement
    []
  }
  
  // Hashable conformance
  func hash(into hasher: inout Hasher) {
    hasher.combine(ObjectIdentifier(V.self))
    hasher.combine(sql)
  }
  
  static func == (lhs: Self, rhs: Self) -> Bool {
    lhs.sql == rhs.sql
  }
}

/// Request type for FetchOne with SQLiteNIO (optional value)
private struct FetchOneStatementNIOOptionalValueRequest<V: QueryRepresentable & Decodable>: SQLiteNIOFetchRequest where V.QueryOutput: Decodable {
  typealias Value = V.QueryOutput?
  
  let sql: String
  let bindings: [QueryBinding]
  
  init(statement: some StructuredQueriesCore.Statement<V>) {
    let (sql, bindings) = statement.query.prepare { _ in "?" }
    self.sql = sql.isEmpty ? "SELECT 1 WHERE 0 -- Empty query generated by StructuredQueries" : sql
    self.bindings = bindings
  }
  
  // SQLiteNIO fetch method
  func fetch(_ connection: SQLiteConnection) async throws -> V.QueryOutput? {
    let sqliteBindings = try bindings.map { binding -> SQLiteData in
      try binding.sqliteData
    }
    
    let rows = try await connection.query(sql, sqliteBindings)
    return try rows.first.map { try $0.decode(V.QueryOutput.self) }
  }
  
  var observedTables: Set<String> {
    // TODO: Extract table names from statement
    []
  }
  
  // Hashable conformance
  func hash(into hasher: inout Hasher) {
    hasher.combine(ObjectIdentifier(V.self))
    hasher.combine(sql)
  }
  
  static func == (lhs: Self, rhs: Self) -> Bool {
    lhs.sql == rhs.sql
  }
}

/// Request type for FetchOne with SQLiteNIO (optional protocol)
private struct FetchOneStatementNIOOptionalRequest<V: QueryRepresentable & _OptionalProtocol>: SQLiteNIOFetchRequest where V.QueryOutput: _OptionalProtocol & Decodable, V.Wrapped: Decodable {
  typealias Value = V.QueryOutput
  
  let sql: String
  let bindings: [QueryBinding]
  
  init(statement: some StructuredQueriesCore.Statement<V>) {
    let (sql, bindings) = statement.query.prepare { _ in "?" }
    self.sql = sql.isEmpty ? "SELECT 1 WHERE 0 -- Empty query generated by StructuredQueries" : sql
    self.bindings = bindings
  }
  
  // SQLiteNIO fetch method
  func fetch(_ connection: SQLiteConnection) async throws -> V.QueryOutput {
    let sqliteBindings = try bindings.map { binding -> SQLiteData in
      try binding.sqliteData
    }
    
    let rows = try await connection.query(sql, sqliteBindings)
    if let row = rows.first {
      return try row.decode(V.QueryOutput.self)
    } else {
      return ._none
    }
  }
  
  var observedTables: Set<String> {
    // TODO: Extract table names from statement
    []
  }
  
  // Hashable conformance
  func hash(into hasher: inout Hasher) {
    hasher.combine(ObjectIdentifier(V.self))
    hasher.combine(sql)
  }
  
  static func == (lhs: Self, rhs: Self) -> Bool {
    lhs.sql == rhs.sql
  }
}

#endif
